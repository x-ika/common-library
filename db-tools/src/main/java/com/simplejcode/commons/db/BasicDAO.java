package com.simplejcode.commons.db;

import java.io.StringReader;
import java.sql.*;
import java.util.List;

import static com.simplejcode.commons.db.DatabaseUtils.*;

public class BasicDAO {

    protected final String namespace;

    protected Connection connection;

    public BasicDAO(String namespace, Connection connection, int statementsBufferSize, StatementPreparation[] config) {
        this.namespace = namespace == null ? "" : namespace + ".";
        this.connection = connection;
        if (connection == null) {
            throw new NullPointerException("The connection should not be null");
        }
        statements = new PreparedStatement[statementsBufferSize];
        if (config != null) {
            prepareAll(config);
        }
    }

    public BasicDAO(String namespace, Connection connection, int statementsBufferSize) {
        this(namespace, connection, statementsBufferSize, null);
    }

    public BasicDAO(String schema, String pkg, Connection connection, int statementsBufferSize) {
        this(schema + "." + pkg, connection, statementsBufferSize);
    }

    public BasicDAO(String schema, String pkg, Connection connection) {
        this(schema + "." + pkg, connection, 1);
    }

    public String getNamespace() {
        return namespace.substring(0, namespace.length() - 1);
    }

    public Connection getConnection() {
        return connection;
    }

    //-----------------------------------------------------------------------------------

    protected final PreparedStatement[] statements;

    public void prepare(int id, String sql) throws SQLException {
        closeStatement(statements[id]);
        statements[id] = connection.prepareStatement(sql);
    }

    public void prepare(int id, String sql, int autoGeneratedKeys) throws SQLException {
        closeStatement(statements[id]);
        statements[id] = connection.prepareStatement(sql, autoGeneratedKeys);
    }

    public void prepareSelect(int id, String table, String... cols) throws SQLException {
        prepare(id, buildSelect(namespace + table, cols));
    }

    public void prepareFuncSelect(int id, String table, String function, String... cols) throws SQLException {
        prepare(id, buildFuncSelect(function, namespace + table, cols));
    }

    public void prepareInsert(int id, String table, String... cols) throws SQLException {
        prepare(id, buildInsert(namespace + table, cols), Statement.RETURN_GENERATED_KEYS);
    }

    public void prepareUpdate(int id, String table, int upd, String... cols) throws SQLException {
        prepare(id, buildUpdate(namespace + table, upd, cols), Statement.RETURN_GENERATED_KEYS);
    }

    public void prepareCall(int id, String sql) throws SQLException {
        closeStatement(statements[id]);
        statements[id] = connection.prepareCall(sql);
    }

    public void prepareCall(int id, String name, int nParams) throws SQLException {
        prepareCall(id, buildSPCall(namespace + name, nParams));
    }

    public void prepareCall(int id, String name, int[][] outTypes, int nParams) throws SQLException {
        prepareCall(id, buildCall(outTypes, nParams, namespace + name));
    }

    public void prepareAll(StatementPreparation[] statementPreparations) {
        for (StatementPreparation c : statementPreparations) {
            try {
                prepareStatement(c);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    public void prepareStatement(StatementPreparation sp) throws SQLException {
        switch (sp.type) {
            case StatementPreparation.TYPE_SELECT:
                prepareSelect(sp.id, sp.tableName, sp.colNames);
                break;
            case StatementPreparation.TYPE_INSERT:
                prepareInsert(sp.id, sp.tableName, sp.colNames);
                break;
            case StatementPreparation.TYPE_UPDATE:
                prepareUpdate(sp.id, sp.tableName, sp.upd, sp.colNames);
                break;
            case StatementPreparation.TYPE_SPCALL:
                prepareCall(sp.id, sp.tableName, sp.upd);
                break;
        }
    }

    //-----------------------------------------------------------------------------------

    public List<Record> executeSelect(int id) throws SQLException {
        return DatabaseUtils.executeSelect(statements[id]);
    }

    public long executeUpdate(int id) throws SQLException {
        return DatabaseUtils.executeUpdate(statements[id]);
    }

    public Object[] execute(int id, String name, int[][] outTypes, long inout, Object... inputParams) throws SQLException {
        final int nParams = outTypes.length + inputParams.length - Long.bitCount(inout);
        if (nParams > 63) {
            throw new RuntimeException("execute method works only for the functions having less than 64 parameters");
        }
        CallableStatement statement = (CallableStatement) statements[id];
        try {
            long in = -2 ^ inout;
            for (int[] outType : outTypes) {
                in ^= 1L << outType[0];
                statement.registerOutParameter(outType[0], outType[1]);
            }
            byte[][] blobs = new byte[nParams][];
            for (Object param : inputParams) {
                int ind = Long.numberOfTrailingZeros(in);
                in ^= 1L << ind;
                if (param instanceof byte[]) {
                    blobs[ind] = (byte[]) param;
                } else {
                    setParam(id, ind, param);
                }
            }

            statement.execute();
            Object[] ret = new Object[outTypes.length];
            for (int i = 0; i < outTypes.length; i++) {
                ret[i] = getParam(id, outTypes[i][0], outTypes[i][1]);
            }
            return ret;

        } finally {
            DatabaseUtils.closeStatement(statement);
        }
    }

    public List<Record> fastSelect(String table, Object... params) throws SQLException {
        try {
            prepareSelect(0, table, extractColumns(params));
            for (int i = 1; i < params.length; i += 2) {
                setParam(0, i + 1 >> 1, params[i]);
            }
            return executeSelect(0);
        } finally {
            closeStatement(statements[0]);
            close();
        }
    }

    public long fastUpdate(String table, Object... params) throws SQLException {
        try {
            prepareInsert(0, table, extractColumns(params));
            for (int i = 1; i < params.length; i += 2) {
                setParam(0, i + 1 >> 1, params[i]);
            }
            return executeUpdate(0);
        } finally {
            closeStatement(statements[0]);
            close();
        }
    }

    private String[] extractColumns(Object... params) {
        int n = params.length;
        String[] cols = new String[n >> 1];
        for (int i = 0; i < n; i += 2) {
            cols[i >> 1] = (String) params[i];
        }
        return cols;
    }

    private void setParam(int id, int ind, Object param) throws SQLException {
        PreparedStatement statement = statements[id];
        if (param instanceof Short) {
            statement.setNull(ind, ((Short) param).intValue());
            return;
        }
        if (param instanceof Integer) {
            statement.setInt(ind, (Integer) param);
            return;
        }
        if (param instanceof Long) {
            statement.setLong(ind, (Long) param);
            return;
        }
        if (param instanceof String) {
            statement.setString(ind, (String) param);
            return;
        }
        if (param instanceof StringBuilder) {
            statement.setClob(ind, new StringReader(param.toString()));
            return;
        }
        if (param instanceof Double) {
            statement.setDouble(ind, (Double) param);
        }
    }

    private Object getParam(int id, int ind, int type) throws SQLException {
        CallableStatement statement = (CallableStatement) statements[id];
        switch (type) {
            case Types.DECIMAL:
                return statement.getDouble(ind);
            case Types.OTHER:
                ResultSet rset = (ResultSet) statement.getObject(ind);
                List<Record> records = DatabaseUtils.cursorToList(rset);
                DatabaseUtils.closeResultSet(rset);
                return records;
        }
        return null;
    }

    //-----------------------------------------------------------------------------------

    public void setAutoCommit(boolean autoCommit) throws SQLException {
        connection.setAutoCommit(autoCommit);
    }

    public void rollback() throws SQLException {
        connection.rollback();
    }

    public void commit() throws SQLException {
        connection.commit();
    }

    public void close() {
        try {
            if (!connection.getAutoCommit()) {
                commit();
                setAutoCommit(true);
            }
        } catch (Exception ignore) {
        }
        for (PreparedStatement statement : statements) {
            DatabaseUtils.closeStatement(statement);
        }
        DatabaseUtils.closeConnection(connection);
    }

}
